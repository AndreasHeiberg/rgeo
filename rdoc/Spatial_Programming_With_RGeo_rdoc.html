<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>Spatial_Programming_With_RGeo - RGeo 0.3.20 Documentation</title>

<link type="text/css" media="screen" href="./rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script type="text/javascript" charset="utf-8" src="./js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/darkfish.js"></script>


<body class="file">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="./index.html">Home</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="./History_rdoc.html">History</a>
  
    <li class="file"><a href="./README_rdoc.html">README</a>
  
    <li class="file"><a href="./Spatial_Programming_With_RGeo_rdoc.html">Spatial_Programming_With_RGeo</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="./RGeo.html">RGeo</a>
  
    <li><a href="./RGeo/Cartesian.html">RGeo::Cartesian</a>
  
    <li><a href="./RGeo/Cartesian/Analysis.html">RGeo::Cartesian::Analysis</a>
  
    <li><a href="./RGeo/Cartesian/BoundingBox.html">RGeo::Cartesian::BoundingBox</a>
  
    <li><a href="./RGeo/Cartesian/Factory.html">RGeo::Cartesian::Factory</a>
  
    <li><a href="./RGeo/CoordSys.html">RGeo::CoordSys</a>
  
    <li><a href="./RGeo/CoordSys/CS.html">RGeo::CoordSys::CS</a>
  
    <li><a href="./RGeo/CoordSys/CS/AngularUnit.html">RGeo::CoordSys::CS::AngularUnit</a>
  
    <li><a href="./RGeo/CoordSys/CS/AxisInfo.html">RGeo::CoordSys::CS::AxisInfo</a>
  
    <li><a href="./RGeo/CoordSys/CS/Base.html">RGeo::CoordSys::CS::Base</a>
  
    <li><a href="./RGeo/CoordSys/CS/CompoundCoordinateSystem.html">RGeo::CoordSys::CS::CompoundCoordinateSystem</a>
  
    <li><a href="./RGeo/CoordSys/CS/CoordinateSystem.html">RGeo::CoordSys::CS::CoordinateSystem</a>
  
    <li><a href="./RGeo/CoordSys/CS/CoordinateSystemFactory.html">RGeo::CoordSys::CS::CoordinateSystemFactory</a>
  
    <li><a href="./RGeo/CoordSys/CS/Datum.html">RGeo::CoordSys::CS::Datum</a>
  
    <li><a href="./RGeo/CoordSys/CS/Ellipsoid.html">RGeo::CoordSys::CS::Ellipsoid</a>
  
    <li><a href="./RGeo/CoordSys/CS/GeocentricCoordinateSystem.html">RGeo::CoordSys::CS::GeocentricCoordinateSystem</a>
  
    <li><a href="./RGeo/CoordSys/CS/GeographicCoordinateSystem.html">RGeo::CoordSys::CS::GeographicCoordinateSystem</a>
  
    <li><a href="./RGeo/CoordSys/CS/HorizontalCoordinateSystem.html">RGeo::CoordSys::CS::HorizontalCoordinateSystem</a>
  
    <li><a href="./RGeo/CoordSys/CS/HorizontalDatum.html">RGeo::CoordSys::CS::HorizontalDatum</a>
  
    <li><a href="./RGeo/CoordSys/CS/Info.html">RGeo::CoordSys::CS::Info</a>
  
    <li><a href="./RGeo/CoordSys/CS/LinearUnit.html">RGeo::CoordSys::CS::LinearUnit</a>
  
    <li><a href="./RGeo/CoordSys/CS/LocalCoordinateSystem.html">RGeo::CoordSys::CS::LocalCoordinateSystem</a>
  
    <li><a href="./RGeo/CoordSys/CS/LocalDatum.html">RGeo::CoordSys::CS::LocalDatum</a>
  
    <li><a href="./RGeo/CoordSys/CS/PrimeMeridian.html">RGeo::CoordSys::CS::PrimeMeridian</a>
  
    <li><a href="./RGeo/CoordSys/CS/ProjectedCoordinateSystem.html">RGeo::CoordSys::CS::ProjectedCoordinateSystem</a>
  
    <li><a href="./RGeo/CoordSys/CS/Projection.html">RGeo::CoordSys::CS::Projection</a>
  
    <li><a href="./RGeo/CoordSys/CS/ProjectionParameter.html">RGeo::CoordSys::CS::ProjectionParameter</a>
  
    <li><a href="./RGeo/CoordSys/CS/Unit.html">RGeo::CoordSys::CS::Unit</a>
  
    <li><a href="./RGeo/CoordSys/CS/VerticalCoordinateSystem.html">RGeo::CoordSys::CS::VerticalCoordinateSystem</a>
  
    <li><a href="./RGeo/CoordSys/CS/VerticalDatum.html">RGeo::CoordSys::CS::VerticalDatum</a>
  
    <li><a href="./RGeo/CoordSys/CS/WGS84ConversionInfo.html">RGeo::CoordSys::CS::WGS84ConversionInfo</a>
  
    <li><a href="./RGeo/CoordSys/Proj4.html">RGeo::CoordSys::Proj4</a>
  
    <li><a href="./RGeo/CoordSys/SRSDatabase.html">RGeo::CoordSys::SRSDatabase</a>
  
    <li><a href="./RGeo/CoordSys/SRSDatabase/ActiveRecordTable.html">RGeo::CoordSys::SRSDatabase::ActiveRecordTable</a>
  
    <li><a href="./RGeo/CoordSys/SRSDatabase/Entry.html">RGeo::CoordSys::SRSDatabase::Entry</a>
  
    <li><a href="./RGeo/CoordSys/SRSDatabase/Interface.html">RGeo::CoordSys::SRSDatabase::Interface</a>
  
    <li><a href="./RGeo/CoordSys/SRSDatabase/Proj4Data.html">RGeo::CoordSys::SRSDatabase::Proj4Data</a>
  
    <li><a href="./RGeo/CoordSys/SRSDatabase/SrOrg.html">RGeo::CoordSys::SRSDatabase::SrOrg</a>
  
    <li><a href="./RGeo/CoordSys/SRSDatabase/UrlReader.html">RGeo::CoordSys::SRSDatabase::UrlReader</a>
  
    <li><a href="./RGeo/Error.html">RGeo::Error</a>
  
    <li><a href="./RGeo/Error/InvalidGeometry.html">RGeo::Error::InvalidGeometry</a>
  
    <li><a href="./RGeo/Error/ParseError.html">RGeo::Error::ParseError</a>
  
    <li><a href="./RGeo/Error/RGeoError.html">RGeo::Error::RGeoError</a>
  
    <li><a href="./RGeo/Error/UnsupportedOperation.html">RGeo::Error::UnsupportedOperation</a>
  
    <li><a href="./RGeo/Feature.html">RGeo::Feature</a>
  
    <li><a href="./RGeo/Feature/Curve.html">RGeo::Feature::Curve</a>
  
    <li><a href="./RGeo/Feature/Factory.html">RGeo::Feature::Factory</a>
  
    <li><a href="./RGeo/Feature/Factory/Instance.html">RGeo::Feature::Factory::Instance</a>
  
    <li><a href="./RGeo/Feature/FactoryGenerator.html">RGeo::Feature::FactoryGenerator</a>
  
    <li><a href="./RGeo/Feature/Geometry.html">RGeo::Feature::Geometry</a>
  
    <li><a href="./RGeo/Feature/GeometryCollection.html">RGeo::Feature::GeometryCollection</a>
  
    <li><a href="./RGeo/Feature/Instance.html">RGeo::Feature::Instance</a>
  
    <li><a href="./RGeo/Feature/Line.html">RGeo::Feature::Line</a>
  
    <li><a href="./RGeo/Feature/LineString.html">RGeo::Feature::LineString</a>
  
    <li><a href="./RGeo/Feature/LinearRing.html">RGeo::Feature::LinearRing</a>
  
    <li><a href="./RGeo/Feature/MixinCollection.html">RGeo::Feature::MixinCollection</a>
  
    <li><a href="./RGeo/Feature/MixinCollection/TypeData.html">RGeo::Feature::MixinCollection::TypeData</a>
  
    <li><a href="./RGeo/Feature/MultiCurve.html">RGeo::Feature::MultiCurve</a>
  
    <li><a href="./RGeo/Feature/MultiLineString.html">RGeo::Feature::MultiLineString</a>
  
    <li><a href="./RGeo/Feature/MultiPoint.html">RGeo::Feature::MultiPoint</a>
  
    <li><a href="./RGeo/Feature/MultiPolygon.html">RGeo::Feature::MultiPolygon</a>
  
    <li><a href="./RGeo/Feature/MultiSurface.html">RGeo::Feature::MultiSurface</a>
  
    <li><a href="./RGeo/Feature/Point.html">RGeo::Feature::Point</a>
  
    <li><a href="./RGeo/Feature/Polygon.html">RGeo::Feature::Polygon</a>
  
    <li><a href="./RGeo/Feature/Surface.html">RGeo::Feature::Surface</a>
  
    <li><a href="./RGeo/Feature/Type.html">RGeo::Feature::Type</a>
  
    <li><a href="./RGeo/Geographic.html">RGeo::Geographic</a>
  
    <li><a href="./RGeo/Geographic/Factory.html">RGeo::Geographic::Factory</a>
  
    <li><a href="./RGeo/Geographic/ProjectedWindow.html">RGeo::Geographic::ProjectedWindow</a>
  
    <li><a href="./RGeo/Geos/CAPIFactory.html">RGeo::Geos::CAPIFactory</a>
  
    <li><a href="./RGeo/Geos/FFIFactory.html">RGeo::Geos::FFIFactory</a>
  
    <li><a href="./RGeo/Geos/CAPIFactory.html">RGeo::Geos::Factory</a>
  
    <li><a href="./RGeo/Geos/ZMFactory.html">RGeo::Geos::ZMFactory</a>
  
    <li><a href="./RGeo/WKRep.html">RGeo::WKRep</a>
  
    <li><a href="./RGeo/WKRep/WKBGenerator.html">RGeo::WKRep::WKBGenerator</a>
  
    <li><a href="./RGeo/WKRep/WKBParser.html">RGeo::WKRep::WKBParser</a>
  
    <li><a href="./RGeo/WKRep/WKTGenerator.html">RGeo::WKRep::WKTGenerator</a>
  
    <li><a href="./RGeo/WKRep/WKTParser.html">RGeo::WKRep::WKTParser</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation" class="description">
  
<h1 id="label-An+Introduction+to+Spatial+Programming+With+RGeo">An Introduction to Spatial Programming With <a href="RGeo.html">RGeo</a></h1>
<ul><li>
<p>by Daniel Azuma</p>
</li><li>
<p>version 0.4 (23 May 2011)</p>
</li></ul>

<h2 id="label-Introduction">Introduction</h2>

<h3 id="label-About+This+Document">About This Document</h3>

<p>One of the most important current trends in the high-tech industry is the
rise of spatial and location-based technologies. Once the exclusive domain
of complex GIS systems, these technologies are now increasingly available
in small applications, websites, and enterprises. This document provides a
brief overview of the concepts, techniques, and tools for implementing
location-aware application features, focusing on the Ruby programming
language and an open-source technology stack.</p>

<p>The contents of this document are as follows.</p>
<ul><li>
<p>Section 1 is a short introduction to geospatial technology, including a
survey of the common tools and libraries available.</p>
</li><li>
<p>Section 2 introduces the standard spatial data types such as points, lines,
and polygons used by most geospatial applications.</p>
</li><li>
<p>Section 3 summarizes the standard spatial operations that are defined on
those data types.</p>
</li><li>
<p>Section 4 discusses coordinate systems and geographic projections, and why
it is important to get them right.</p>
</li><li>
<p>Section 5 covers the most common open source spatial databases.</p>
</li><li>
<p>Section 6 briefly covers interoperability with location services and other
externally-sourced geospatial data.</p>
</li></ul>

<p>Geographic information systems (GIS) is a broad and highly sophisticated
field, and this introduction will only scratch the surface of the current
state of the art. The goal is not to be comprehensive, but to summarize the
important elements, and reference outside resources for readers seeking
more detailed information.</p>

<h3 id="label-About+The+Author">About The Author</h3>

<p><a href="http://www.daniel-azuma.com/">Daniel Azuma</a> is the chief
software architect and a co-founder of <a
href="http://www.geopage.com/">GeoPage, Inc.</a>, a Seattle-based startup
developing location-aware consumer applications. Daniel has been working
with Ruby on Rails since 2006, and has a background in computer graphics
and visualization. He is also the author of RGeo, the advanced spatial data
library for Ruby covered in this document.</p>

<h2 id="label-1.+Space%3A+The+Next+Frontier">1. Space: The Next Frontier</h2>

<h3 id="label-1.1.+Why+Spatial+Programming%3F">1.1. Why Spatial Programming?</h3>

<p>By 2010, location had established itself as one of the hottest emerging
technological trends. In January, a Juniper Research report predicted that
mobile location services alone could drive revenues of nearly $13 billion
by 2014 (see <a
href="http://techcrunch.com/2010/02/23/location-based-services-revenue/">TechCrunch
article</a>), while location dominated new feature offerings from a myriad
of startups as well as from giants such as Facebook and Twitter. Although
the underlying disciplines of computer-assisted cartography and geographic
information systems (GIS) have been around for several decades, they have
broken into mainstream consumer technology only very recently. This has
largely been due to a few key developments, notably, the success of online
mapping applications beginning with Google Maps, and the ubiquity of mobile
GPS devices especially in mobile phones.</p>

<p>Despite this growing interest, location-aware applications remain difficult
to develop because the concepts and techniques involved are only beginning
to make their way into the mainstream developer consciousness and tools.
The primary purpose of this document is to cover the basics that a Ruby or
Ruby On Rails developer needs to know when developing with location data,
and to introduce the tools and resources that are available.</p>

<h3 id="label-1.2.+The+Emerging+Spatial+Ecosystem">1.2. The Emerging Spatial Ecosystem</h3>

<p>Fortunately, a number of software libraries and organizations now exist to
promote and assist developing spatial applications. Here we will survey
some of the popular and emerging open software systems available for
integration into your location-aware application.</p>

<p>Visualization tools have advanced considerably in recent years. Mapping
services such as <a href="http://maps.google.com/">Google Maps</a> and <a
href="http://www.bing.com/maps/">Bing Maps</a> now have extensive API
support for developing mapping applications. An open mapping service, <a
href="http://www.openstreetmap.org/">OpenStreetMap</a>, has also been
launched and is gaining momentum. In addition, tools which let you serve
your own map data, such as <a href="http://openlayers.org/">OpenLayers</a>
and <a href="http://polymaps.org/">PolyMaps</a>, have also appeared.</p>

<p>Most major relational databases now support spatial extensions. The <a
href="http://mysql.com/">MySQL</a> database provides basic spatial column
support out of the box. Third-party add-on libraries exist for <a
href="http://www.sqlite.org/">Sqlite3</a> and <a
href="http://www.postgresql.org/">PostgreSQL</a> in the form of <a
href="http://www.gaia-gis.it/spatialite/">SpatiaLite</a> and <a
href="http://www.postgis.org/">PostGIS</a>, respectively. Commercial
databases such as Oracle and Microsoft SQL Server also provide facilities
for storing and querying spatial data. Spatial features are also appearing
in non-relational data stores. <a
href="http://www.mongodb.org/">MongoDB</a> recently introduced geospatial
indexing, <a href="http://lucene.apache.org/solr/">Solr</a> supports
spatial queries in the latest release of its Lucene-based search engine,
and <a href="http://sphinxsearch.com/">Sphinx</a> also provides limited
spatial search capabilities.</p>

<p>A variety of data services have also appeared. Geocoding, the process
approximating a latitude/longitude coordinate from a street address, is now
offered by most major mapping service vendors such as <a
href="http://code.google.com/apis/maps/documentation/geocoding/">Google</a>,
<a href="http://www.microsoft.com/maps/developers/">Microsoft</a>, and <a
href="http://developer.yahoo.com/geo/placefinder/">Yahoo</a>. Place
databases with geocoded business and major location listings are now also
available from a variety of vendors. Several services, notably <a
href="http://www.simplegeo.com/">SimpleGeo</a>, have recently appeared for
cloud-based storage and querying of custom location data.</p>

<p>Integrating these existing services in a web application is often a
challenge, but a few integration libraries and frameworks do exist. <a
href="http://geodjango.org/">GeoDjango</a> is an add-on for the
Python-based Django web framework for building location-based applications.
<a href="http://github.com/dazuma/rgeo">RGeo</a> is a suite of libraries
for Ruby that can perform the same function for Ruby on Rails.</p>

<p>Perhaps most important of all, however, are the organizations that have
appeared to support the development of geospatial standards and software.
The <a href="http://www.opengeospatial.org/">Open Geospatial Consortium</a>
(OGC) is an international consortium of companies, government agencies, and
other organizations that promote interoperability by developing open
standards and interfaces for geospatial software systems. Many of the
concepts, data types, and operations described in this document were
standardized by the OGC. The <a href="http://www.osgeo.org/">Open Source
Geospatial Foundation</a> develops and supports a variety of open source
geospatial software, including PostGIS, GEOS, Proj, and others we will
cover in this document. The <a href="http://www.epsg.org/">OGP Geomatics
Committee</a> (formerly EPSG, the European Petroleum Survey Group) is part
of an industry association maintaining the <em>de facto</em> standard EPSG
geodetic data set, a set of coordinate systems and transformations used
internationally to describe global position. These and other organizations
form the backbone of geospatial technology, and most geospatial
applications will interact at least indirectly with their services.</p>

<h3 id="label-1.3.+Ruby+Libraries+and+RGeo">1.3. Ruby Libraries and RGeo</h3>

<p>Ruby developers have had access to a fair number of spatial tools,
primarily integration libraries for external services. <a
href="http://geokit.rubyforge.org/">Geokit</a> and <a
href="http://www.rubygeocoder.com/">Geocoder</a> provide a common
interfaces for querying geocoding services, and basic ActiveRecord
extensions for simple spatial queries. <a
href="http://ym4r.rubyforge.org/">YM4R</a> provides a simple interface for
integrating the Google and Yahoo map visualization tools in a Ruby
application. Finally, <a href="http://georuby.rubyforge.org/">GeoRuby</a>
provides classes for basic spatial data types such as points, lines, and
polygons, and the add-on library <a
href="http://github.com/fragility/spatial_adapter">spatial_adapter</a>
hacks a few of the popular ActiveRecord database adapters to support
spatial columns in the database.</p>

<p>In this document, we will cover <a
href="http://github.com/dazuma/rgeo">RGeo</a>, a recent spatial data
library for Ruby that provides a complete and robust implementation of the
standard OGC spatial data types and operations. It covers some of the same
functionality as GeoRuby and spatial_adapter. However, where GeoRuby
implements only a minimal subset of the OGC feature interfaces, RGeo
supports the entire specification, as well as providing many features and
extensions not available with the older libraries.</p>

<p>RGeo comprises several libraries, distributed as gems: a core library, and
a suite of optional add-on modules. The core library, distributed as the <a
href="http://github.com/dazuma/rgeo">rgeo</a> gem, includes the spatial
data implementation itself. Currently available add-on modules include <a
href="http://github.com/dazuma/rgeo-geojson">rgeo-geojson</a>, which reads
and writes the <a href="http://www.geojson.org/">GeoJSON</a> format, and <a
href="http://github.com/dazuma/rgeo-shapefile">rgeo-shapefile</a>, which
reads ESRI shapefiles. A number of ActiveRecord adapters also utilize RGeo
to communicate with spatial databases; these include <a
href="http://github.com/dazuma/activerecord-mysqlspatial-adapter">mysqlspatial</a>,
<a
href="http://github.com/dazuma/activerecord-mysql2spatial-adapter">mysql2spatial</a>,
<a
href="http://github.com/dazuma/activerecord-spatialite-adapter">spatialite</a>,
and <a
href="http://github.com/dazuma/activerecord-postgis-adapter">postgis</a>.</p>

<h2 id="label-2.+Spatial+Data+Types">2. Spatial Data Types</h2>

<p>This section will cover the standard types of spatial data used in
geospatial applications.</p>

<h3 id="label-2.1.+The+Simple+Features+Specification">2.1. The Simple Features Specification</h3>

<p>The Open Geospatial Consortium (OGC) defines and publishes a specification
entitled “<a href="http://www.opengeospatial.org/standards/sfa">Geographic
information – Simple feature access</a>”, which defines, among other
things, a set of spatial data types and operations that can be done on
them. This standard, which we will refer to as the Simple Features
Specification (SFS), defines the core types and interfaces used by most
spatial applications and databases. Although more recent versions of the
spec are now available, most current implementations, including RGeo,
follow version 1.1 of the SFS, and this is the specification we will cover
here.</p>

<p>A “feature” in the SFS is a geometric object in 2 or 3 dimensional space.
These objects can be points, lines, curves, surfaces, and polygons– in
general, most 0, 1, or 2 dimensional objects are supported. Each of these
objects is identified by coordinates (X, Y, and sometimes Z), and has an
object-oriented interface associated with it, defining a set of operations
that can be performed. In RGeo, these interfaces exist as modules in the <a
href="RGeo/Feature.html">RGeo::Feature</a> namespace.</p>

<p>We will quickly cover the types of geometric objects supported, and then
discuss how to use RGeo to create and manipulate spatial data as Ruby
objects.</p>

<h3 id="label-2.2.+Coordinates">2.2. Coordinates</h3>

<p>Geometric objects generally exist in a two-dimensional domain (such as a
plane or a globe) identified by X and Y coordinates. These coordinates
could be screen coordinates, as on a map displayed on a computer screen,
they could be longitude/latitude coordinates, where X represents longitude
and Y represents latitude, or they could be in a different coordinate
system altogether.</p>

<p>Strictly speaking, version 1.1 of the SFS supports only two dimensions.
However, many implementations can represent up to four coordinates,
including an optional Z and M coordinate. Z, when present, is generally
used for a third dimension of location; for example, it could represent
altitude, a distance above or below the surface of the earth. M, when
present, is used to represent a “measure”, a scalar value that could change
across an object. The measure could, for example, represent temperature,
population density, or some other function of location. Most current
implementations, though they can represent and store Z and M, will not
actually perform any analysis with those coordinates; they act merely as
additional data fields.</p>

<h3 id="label-2.3.+Point">2.3. Point</h3>

<p>An SFS “Point” is a single 0-dimensional point in space. Points are
typically used in location applications to represent a single location,
displayed as a map marker. You can retrieve the coordinates X and Y (and
optionally Z and M) from a point object.</p>

<h3 id="label-2.4.+LineString">2.4. LineString</h3>

<p>An SFS “LineString” is a set of one or more connected line segments
representing a single continuous, piecewise linear path. It could, for
example, represent the path of a single street, the full driving directions
from one point to another, or the path of a waterway. It is defined by
connecting a series of points in order with line segments, and you can
retrieve those points from the LineString object.</p>

<p>LineString itself has two subclases, Line and LinearRing. Line is
restricted to a single line segment (i.e. two points). LinearRing is a
“closed” LineString, in which the two endpoints are coincident.</p>

<p>(LineString is actually a subclass of the more general abstract class
“Curve”, which need not be piecewise linear. However, Curve is not by
itself instantiable, and the current SFS version does not actually specify
another type of instantiable Curve that is not a LineString.)</p>

<h3 id="label-2.5.+Polygon">2.5. Polygon</h3>

<p>An SFS “Polygon” is a connected region of two-dimensional space. Its outer
boundary is defined as a LinearRing, so it can have any number of straight
“sides”. Polygons can also optionally contain “holes”, represented by inner
boundaries which are also LinearRings. You can retrieve the outer and inner
boundaries from a Polygon object as LinearRing objects. Polygons are ideal
for representing single plots of land such as property boundaries, or
larger regions of the earth’s surface such as city, state, or national
boundaries, time zones, lakes, and so forth, as long as they are
contiguous.</p>

<p>(Polygon is also a subclass of a more general abstract class, this one
called “Surface”. In general, the boundaries of a Surface need not be
piecewise linear. However, Surface is not by itself instantiable, and the
current SFS version does not actually specify another type of instantiable
Surface other than Polygon.)</p>

<h3 id="label-2.6.+MultiPoint">2.6. MultiPoint</h3>

<p>An SFS “MultiPoint” is a collection of zero or more Point objects. You
might, for example, represent the locations of all your favorite
restaurants as a MultiPoint.</p>

<h3 id="label-2.7.+MultiLineString">2.7. MultiLineString</h3>

<p>An SFS “MultiLineString” is a collection of zero or more LineString
objects. It might be used, for example, to represent all the currently
“congested” sections of a city’s freeways during rush hour. It could even,
in principle, represent the entire street map of a city, though such a data
structure might be too large to be practical.</p>

<p>(MultiLineString is a subclass of the non-instantiable abstract class
MultiCurve.)</p>

<h3 id="label-2.8.+MultiPolygon">2.8. MultiPolygon</h3>

<p>An SFS “MultiPolygon” is a collection of zero or more Polygon objects. It
also has a few additional restrictions, notably that the constituent
polygons must all be disjoint and cannot overlap. MultiPolygons are used to
represent a region which could have multiple unconnected parts.</p>

<p>(MultiPolygon is a subclass of the non-instantiable abstract class
MultiSurface.)</p>

<h3 id="label-2.9.+Geometry+and+GeometryCollection">2.9. Geometry and GeometryCollection</h3>

<p>The various geometric data types described above are arranged in a class
hierarchy. The base class of this hierarchy is Geometry. The MultiPoint,
MultiLineString, and MultiPolygon types (or more precisely, MultiPoint,
MultiCurve, and MultiSurface) are subclasses of a more general data type
called GeometryCollection. GeometryCollection can also be instantiated by
itself. It represents a general collection of other geometry objects, each
of which can be any type.</p>

<p>For complete details on the geometry class hierarchy, download the actual
<a href="http://www.opengeospatial.org/standards/sfa">Simple Features
Specification</a>. I recommend downloading version 1.1, because the newer
versions (1.2 and later) describe additional types and features that are
not commonly available in current implementations. That additional
information may be confusing.</p>

<h3 id="label-2.10.+RGeo+Geometry+Factories">2.10. RGeo Geometry Factories</h3>

<p>The data types we have covered here are actually merely interface
specifications. RGeo provides several different concrete implementations of
these data type interfaces, intended for different use cases. For example,
the RGeo::Geos implementation is RGeo’s main implementation which provides
every data type and every operation defined by the SFS. However, that
implementation requires a third-party C library, GEOS, to be installed. In
cases where that library is not available, RGeo provides an alternative,
the Simple Cartesian implementation, which is a pure Ruby implementation
that provides every data type but does not implement some of the more
advanced geometric operations. RGeo also provides further implementations
that are designed specifically to work with geographic (longitude/latitude)
coordinates, and different projections and ways of performing calculations
on the earth’s surface. These different implementations are described in
more detail in the section on Coordinate Systems and Projections.</p>

<p>Each concrete implementation is represented in RGeo by a factory. A factory
is an object that represents the coordinate system and other settings for
that implementation. It also provides methods for creating actual geometric
objects for that implementation, as defined in the <a
href="RGeo/Feature/Factory.html">RGeo::Feature::Factory</a> interface. For
example:</p>

<pre>factory = get_my_factory()
point1 = factory.point(1, 2)
point2 = factory.point(3, -1)
line = factory.line_string([point1, point2])</pre>

<p>The most common factory used by RGeo is the “preferred Cartesian” factory.
This factory uses a flat (Cartesian) coordinate system, and is implemented
by GEOS (if available) or using the pure Ruby alternative if not. It can be
retrieved by calling:</p>

<pre>factory = ::RGeo::Cartesian.preferred_factory()</pre>

<p>Another common factory you might want to use is the “simple Mercator”
factory. This is a geographic factory intended for simple location-based
applications that use Google or Bing Maps as a visualization tool. Its
coordinate system is longitude-latitude, but it also has a built-in
facility for converting those coordinates to the flat “tiling” coordinate
system used by the map. You can retrieve it by calling:</p>

<pre>factory = ::RGeo::Geographic.simple_mercator_factory()</pre>

<p>In many cases, these factory creation methods take additional optional
arguments that enable various features. For example, the preferred
Cartesian factory, by default, uses only X and Y coordinates. You can
activate Z and/or M coordinates by passing an appropriate argument, e.g.:</p>

<pre class="ruby"><span class="ruby-identifier">factory</span> = <span class="ruby-operator">::</span><span class="ruby-constant">RGeo</span><span class="ruby-operator">::</span><span class="ruby-constant">Cartesian</span>.<span class="ruby-identifier">preferred_factory</span>(:<span class="ruby-identifier">has_z_coordinate</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>)
<span class="ruby-identifier">factory</span>.<span class="ruby-identifier">property</span>(:<span class="ruby-identifier">has_z_coordinate</span>)  <span class="ruby-comment"># returns true</span>
<span class="ruby-identifier">factory</span>.<span class="ruby-identifier">property</span>(:<span class="ruby-identifier">has_m_coordinate</span>)  <span class="ruby-comment"># returns false</span>
<span class="ruby-identifier">point</span> = <span class="ruby-identifier">factory</span>.<span class="ruby-identifier">point</span>(<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)       <span class="ruby-comment"># this point has a Z coordinate</span>
</pre>

<p>Note that, in many cases, the factory class itself as well as the actual
implementation classes for the geometric objects, are opaque in RGeo. You
should refer to the appropriate interfaces in the <a
href="RGeo/Feature.html">RGeo::Feature</a> namespace for the methods you
can call.</p>

<h2 id="label-3.+Spatial+Operations">3. Spatial Operations</h2>

<p>In addition to representing geometric data, the SFS interfaces define a
suite of basic operations on this data. These operations are available in
many forms, depending on the type of software system. Spatial databases
such as PostGIS define these as SQL functions that can be used to write
queries. RGeo’s goal is to make geometric objects available to Ruby
programs, and so these operations are exposed as methods on the geometric
Ruby objects.</p>

<p>These operations cover a wide range of functionality, and some involve
difficult problems of computational geometry, especially over a non-flat
coordinate system such as geographic coordinates. RGeo provides a complete
implementation for flat Cartesian coordinates that utilizes the <a
href="http://trac.osgeo.org/geos/">GEOS</a> library internally. However,
some of RGeo’s other implementations provide only a subset of these
operations. If you use the PostGIS database, you will find a similar
situation. The “geometry” data types actually use GEOS internally to
perform geometric computations, and pretty much all functions are
available. However, the “geography” data type, which operates on a curved
coordinate system, implements only a handful of the defined functions.</p>

<h3 id="label-3.1.+Basic+Properties">3.1. Basic Properties</h3>

<p>Most geometry types have a “degenerate” form representing no geometry. For
example, a GeometryCollection may contain no items, or a LineString may
contain no points. This state is indicated by the
<code>Geometry#is_empty?</code> method. In RGeo, any geometry type except
Point may be empty.</p>

<pre>factory = ::RGeo::Cartesian.preferred_factory
factory.point(1, 2).is_empty?     # returns false
factory.collection([]).is_empty?  # returns true</pre>

<p>A second common property of geometry objects is “simplicity”, which
basically means the geometry doesn’t intersect or repeat itself. For
example, a LineString that intersects itself is not simple, nor is a
MultiPoint that contains the same point more than once. Sometimes, a
geometric analysis algorithm will have simplicity as a precondition. This
property is indicated by the <code>Geometry#is_simple?</code> method.</p>

<pre>factory = ::RGeo::Cartesian.preferred_factory
p00 = factory.point(0, 0)
p01 = factory.point(0, 1)
p11 = factory.point(1, 1)
p10 = factory.point(1, 0)
zigzag_line = factory.line_string([p00, p10, p01, p11])
zigzag_line.is_simple?         # returns true
self_crossing_line = factory.line_string([p00, p11, p01, p10])
self_crossing_line.is_simple?  # returns false</pre>

<p>All geometry objects also contain a “spatial reference ID”, returned by the
<code>Geometry#srid</code> method. This is an external ID reference
indicating the “spatial reference system”, or coordinate system in use by
the geometry. See the section on Coordinate Systems and Projections for
further discussion.</p>

<h3 id="label-3.2.+Relational+Operations">3.2. Relational Operations</h3>

<p>The SFS specifies a suite of comparison operations that test geometric
objects for such relational predicates as equality, overlap, containment,
and so forth. In RGeo, these operations are implemented by methods that
return booleans. e.g.</p>

<pre>if polygon1.overlaps?(polygon2)
  # do something
end</pre>

<p>I do not have space here to describe the different comparison operations in
detail. See the SFS for the precise defintions. However, I do want to point
out one particular feature of RGeo related to equality checking. The Ruby
language has a number of different methods for testing different “forms” of
equality. For example:</p>

<pre class="ruby"><span class="ruby-value">1</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>        <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-value">1</span> <span class="ruby-operator">==</span> <span class="ruby-value">1.0</span>      <span class="ruby-comment"># =&gt; true  (because the values are the same)</span>
<span class="ruby-value">1</span>.<span class="ruby-identifier">eql?</span>(<span class="ruby-value">1</span>)     <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-value">1</span>.<span class="ruby-identifier">eql?</span>(<span class="ruby-value">1.0</span>)   <span class="ruby-comment"># =&gt; false  (because the classes are different)</span>
<span class="ruby-identifier">a</span> = <span class="ruby-string">&quot;foo&quot;</span>
<span class="ruby-identifier">b</span> = <span class="ruby-string">&quot;foo&quot;</span>
<span class="ruby-identifier">a</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">b</span>        <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">eql?</span>(<span class="ruby-identifier">b</span>)     <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">equal?</span>(<span class="ruby-identifier">b</span>)  <span class="ruby-comment"># =&gt; false  (because they are different objects)</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">equal?</span>(<span class="ruby-identifier">a</span>)  <span class="ruby-comment"># =&gt; true</span>
</pre>

<p>In general, Ruby has three forms of equality: value equality (tested by the
<code>==</code> operator), object equality (tested by the <code>eql?</code>
method), and object identity (tested by the <code>equal?</code> method).</p>

<p>Similarly, RGeo’s equality checking comes in several forms: geometric
equality, representational equality, and object identity. Geometric
equality is tested by the SFS method <code>equals?</code>, as well as the
<code>==</code> operator. This type of equality indicates two objects that
may be different representations of the same geometry, for example, a
LineString and its reverse, or a Point and a MultiPoint that contains only
that same point. Representational equality, tested by <code>eql?</code>,
means the same representation but possibly distinct objects. Object
identity, tested by <code>equal?</code>, represents the same object, as
with other Ruby types.</p>

<pre class="ruby"><span class="ruby-identifier">p1</span> = <span class="ruby-identifier">factory</span>.<span class="ruby-identifier">point</span>(<span class="ruby-value">1</span>, <span class="ruby-value">1</span>)
<span class="ruby-identifier">p2</span> = <span class="ruby-identifier">factory</span>.<span class="ruby-identifier">point</span>(<span class="ruby-value">1</span>, <span class="ruby-value">1</span>)
<span class="ruby-identifier">mp</span> = <span class="ruby-identifier">factory</span>.<span class="ruby-identifier">multi_point</span>([<span class="ruby-identifier">p1</span>])
<span class="ruby-identifier">p1</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">p2</span>        <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">p1</span>.<span class="ruby-identifier">equals?</span>(<span class="ruby-identifier">mp</span>)   <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">p1</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">mp</span>        <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">p1</span>.<span class="ruby-identifier">eql?</span>(<span class="ruby-identifier">mp</span>)     <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">p1</span>.<span class="ruby-identifier">eql?</span>(<span class="ruby-identifier">p2</span>)     <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">p1</span>.<span class="ruby-identifier">equal?</span>(<span class="ruby-identifier">p2</span>)  <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">p1</span>.<span class="ruby-identifier">equal?</span>(<span class="ruby-identifier">p1</span>)  <span class="ruby-comment"># =&gt; true</span>
</pre>

<h3 id="label-3.3.+Binary+Spatial+Operations">3.3. Binary Spatial Operations</h3>

<p>The SFS also provides several operations that take two geometries and yield
a third. For example, you can calculate the intersection, union, or
difference between two geometries. In addition to the methods specified by
the SFS interfaces, RGeo provides operators for some of these calculations.</p>

<pre>p1 = factory.point(1, 1)
p2 = factory.point(2, 2)
union = p1.union(p2)      # or p1 + p2
union.geometry_type       # returns RGeo::Feature::MultiPoint
union.num_geometries      # returns 2
diff = p1.difference(p2)  # or p1 - p2
diff.is_empty?            # returns true</pre>

<h3 id="label-3.4.+Unary+Spatial+Operations">3.4. Unary Spatial Operations</h3>

<p>Methods are provided to compute the boundary of an object, the envelope
(i.e. the bounding box), and the convex hull. In addition, there is a
“buffer” method that attempts to return a polygon approximating the area
within a given distance from the object. Note that, because the SFS does
not yet define any geometric types with curved edges, most buffers will be
polygonal approximations.</p>

<h3 id="label-3.5.+Size+and+Distance">3.5. Size and Distance</h3>

<p>Several size and distance calculations are available. You can compute the
distance between two geometric objects, the length of a LineString, or the
area of a Polygon. Note that there will be some cases when these
computations don’t make much sense due to the coordinate system.</p>

<pre>p00 = factory.point(0, 0)
p20 = factory.point(2, 0)
p11 = factory.point(1, 1)
p00.distance(p11)              # returns 1.41421356...
line = factory.line(p00, p20)
line.length                    # returns 2
line.distance(p11)             # returns 1
ring = factory.linear_ring([p00, p11, p20, p00])
ring.length                    # returns 4.82842712...
ring.distance(p11)             # returns 0
poly = factory.polygon(ring)
poly.area                      # returns 1</pre>

<h3 id="label-3.6.+Serialization">3.6. Serialization</h3>

<p>The SFS defines two serialization schemes for geometric objects, known as
the WKT (well-known text) and WKB (well-known binary) formats. The WKT is
often used for textual display and transmission of a geometric object,
while the WKB is sometimes used as an internal data format by spatial
databases. Geometric objects in RGeo define the <code>as_text</code> and
<code>as_binary</code> methods to serialize the object into a data string,
while RGeo factories provide <code>parse_wkt</code> and
<code>parse_wkb</code> methods to reconstruct geometric objects from their
serialized form.</p>

<pre>p00 = factory.point(0, 0)
p00.as_text                     # returns &quot;POINT (0.0 0.0)&quot;
p10 = factory.point(1, 0)
line = factory.line(p00, p10)
line.as_text                    # returns &quot;LINESTRING (0.0 0.0, 1.0 0.0)&quot;
p = factory.parse_wkt('POINT (3 4)')
p.x                             # returns 3.0</pre>

<p>Note that there are several key shortcomings in the WKT and WKB formats as
strictly defined by the SFS. In particular, neither format has official
support for Z or M coordinates, and neither provides a way to specify the
coordinate system (i.e. spatial reference ID) in which the object is
represented. Because of this, variants of these formats have been
developed. The most important to know are probably the EWKT and EWKB (or
“extended” well-known formats) used by the PostGIS database, which supports
Z and M as well as SRID. More recent versions of the SFS also have defined
extensions to handle Z and M coordinates, but do not embed an SRID. RGeo
supports parsing and generating these variants through the <a
href="RGeo/WKRep.html">RGeo::WKRep</a> module.</p>

<h2 id="label-4.+Coordinate+Systems+and+Projections">4. Coordinate Systems and Projections</h2>

<p>So far, we have discussed geometric data and operations mostly without
reference to coordinate system. However, coordinate system is a critical
component for interpreting what a piece of data means. If you have a point
(1, 2), are the 1 and 2 measured in meters? Miles? Degrees? And where are
they measured from? What is the origin (0, 0), and what directions do X and
Y represent?</p>

<p>Generally, the spatial technologies we’re discussing are used to represent
location, objects on the earth’s surface. In this section, we’ll cover the
coordinate systems that you’ll use for geolocation, as well as the issues
you’ll face.</p>

<h3 id="label-4.1.+The+World+is+Not+Flat">4.1. The World is Not Flat</h3>

<p>First off, most of us agree that the earth is not flat, but has a shape
resembling a slightly flattened ball. This immediately results in a whole
host of complications when dealing with geometric objects on the earth’s
surface. Distance can’t quite be computed accurately using the familiar
formulas you learned in high school geometry. Lines that start off parallel
will eventually cross. And if you try to display things on a flat computer
monitor, you will end up with various kinds of distortion.</p>

<p>Let’s take a simple example. Suppose we have a simple LineString with two
points: starting in Vancouver, Canada, and ending in Frankfurt, Germany,
both located at around 50 degrees north latitude. The LineString would
consist of a straight line between those two points. But what is meant by
“straight”? Does the shape follow the 50 degrees north latitude line,
passing through Newfoundland? Or does it follow the actual shortest path on
the globe, which passes much further north, close to Reykjavik, Iceland?
(For a detailed explanation, see Morten Nielsen’s post <a
href="http://www.sharpgis.net/post/2008/01/12/Straight-lines-on-a-sphere.aspx">“Straight
Lines on a Sphere”</a>, which also includes some helpful diagrams.) If you
were to call the SFS “distance” function to measure the distance between
this LineString and a Point located at Reykjavik, what would you get?</p>

<p>The answer is, it depends on the coordinate system you’re using.</p>

<h3 id="label-4.2.+Geographic+Coordinates+And+Projections">4.2. Geographic Coordinates And Projections</h3>

<p>GIS systems typically represent locations in one of three different types
of coordinate systems: geocentric coordinates, geographic coordinates, and
projected coordinates. Geocentric coordinate systems typically locate the
origin of a three-dimensional Cartesian coordinate system at the center of
the earth. They are not commonly used in an application-level interface,
but are often a convenient coordinate system for running computational
geometry algorithms. Geographic coordinates use the familiar latitude and
longitude measurements, and sometimes also include altitude. These
coordinates use a curved surface, either a sphere or an ellipsoid, as the
domain, and perform geometric calculations on that non-flat domain.
Projected coordinates involve transforming the curved domain of the earth’s
surface onto a flat domain such as a map display. Projected coordinates,
then, are actually X-Y coordinates on the map itself: for example, pixel
coordinates.</p>

<p>In our Vancouver to Frankfurt example, the path of a “straight” line is
defined by the type of coordinate system being used. A geocentric
coordinate system operates in 3-d space, and so a straight line will
actually pass through the interior of the earth. A straight line in a
geographic coordinate system (latitudes and longitudes) is typically
defined as a geodesic, the shortest path between two points along the
earth’s surface. This path will take the line near Reykjavik. In a
projected coordinate system, a straight line is defined as a straight line
on the projection– that is, a straight line drawn on the flat map. Google
and Bing maps use a Mercator projection, in which lines of latitude are
straight horizontal lines, so the LineString will follow the 50 degrees
latitude line, passing through Newfoundland.</p>

<p>It is important to note that the actual <em>shape</em> of the geometry is
different depending on the coordinate system. If you “project” the geodesic
(the straight Line in geographic coordinates) into a Mercator-projected
Google map, the line will be curved. Therefore, the coordinate system is an
integral part of the geometric object. If you get your coordinate systems
mixed up, you may get incorrect results when you run a database query or a
geometric operation. Morten Nielsen gives an example in <a
href="http://www.sharpgis.net/post/2009/02/06/Why-EPSG4326-is-usually-the-wrong-e2809cprojectione2809d.aspx">this
post</a>.</p>

<pre>flat_factory = RGeo::Geos.factory
curved_factory = RGeo::Geographic.spherical_factory
flat_line = flat_factory.line(flat_factory.point(0, 0),
                              flat_factory.point(1, 1))
curved_line = curved_factory.line(curved_factory.point(0, 0),
                                  curved_factory.point(1, 1))
# flat_line and curved_line represent different shapes!</pre>

<p>RGeo provides access to different coordinate systems via its factories, as
we saw earlier. If you are implementing geolocation, you will typically use
one of the geographic factories which represent coordinates as latitude and
longitude. Note, however, that RGeo provides both projected and
non-projected geographic factories. Projected factories are tied to a
particular projection, representing coordinates as latitude and longitude,
but doing calculations in the projection. If you use the simple mercator
factory, a projected factory, the line between Vancouver and Frankfurt will
follow the 50 degree latitude line, and so it will intersect a polygon
representing Newfoundland. Non-projected factories perform calculations on
a curved earth. Using the spherical factory, a non-projected factory that
assumes the earth is a sphere, the line between Vancouver and Frankfurt
will intersect a polygon representing Greenland. (In the future, RGeo
should also provide an ellipsoidal factory that performs the more complex
calculations needed to model the earth as a <em>flattened</em> sphere. This
feature is not available yet.)</p>

<p>Some database systems behave similarly. PostGIS, for example, provides
separate “geometry” and “geography” types. The former assumes a flat
domain: it will behave similarly to RGeo’s simple mercator factory for a
horizontal line (though for an oblique line, it will behave differently
since the vertical axis is nonuniform in the Mercator projection.) The
PostGIS “geography” type, however, operates on a curved earth, similar to
RGeo’s spherical factory.</p>

<p>Does this matter in your application? The answer is, it depends: on what
kind of data you have, how it will be analyzed or displayed, and how much
accuracy you need. For a simple application that displays point locations
or small-scale paths and areas on a Google map, you can probably safely
ignore the issue. It would probably be easiest to simply use RGeo’s
non-projected spherical factory, and the “geography” type if you are using
PostGIS. The Google maps system automatically transforms your
latitude-longitude coordinates into projected map coordinates when it
displays markers and polygons. Remember the Vancouver to Frankfurt problem,
however: if you display a line or polygon that is very large, the straight
sides as displayed on the Google map may not be straight on the actual
curved earth, and a LineString represented as a non-projected geographic
object should not appear straight on the map. If your objects cover large
areas of the globe, or for better accuracy or more sophisticated
applications, you will need to pay explicit attention to projections.</p>

<h3 id="label-4.3.+Geodetic+and+Projection+Parameters">4.3. Geodetic and Projection Parameters</h3>

<p>This subsection covers some more advanced topics that most developers may
not need to deal with directly, but I believe it is important to have at
least a high-level understanding of them.</p>

<p>Simply put, there’s more to a coordinate system than just the type:
geocentric, geographic, or projected. For a geocentric coordinate system,
we know it’s centered at the center of the earth, but where <em>is</em> the
center of the earth? Which direction do the axes point? And do we measure
the units in meters, miles, or light-years? For a geographic coordinate
system, again, we need a center and orientation (i.e. where is the “zero
longitude” line?), but we also need to define specifically <em>which</em>
“latitude”. The latitude commonly used is the “geodetic latitude”, which is
the angle between the equator and what is normal (i.e. vertical) to the
surface of the earth. This means it is dependent on one’s model of the
earth’s surface, whether you use a sphere or a flattened ellipsoid, and how
much flattening you choose. The same location on the earth’s surface may
have different latitudes depending on which system you use! As for
projected systems, not only do we need to specify which projection to use
(and there are hundreds defined), but we also need to know which geographic
(latitude-longitude) system to start from. That is, because a map
projection is a function mapping latitude/longitude to flat coordinates, we
need to specify <em>which</em> latitude/longitude.</p>

<p>To completely specify a coordinate system, then, a number of parameters are
involved. Below I briefly describe the major parameters and what they mean:</p>

<p><strong>Ellipsoid</strong>: (Also called a <strong>sphereoid</strong>) An
ellipsoid is an approximation of the shape of the earth, defined by the
length of the <strong>semi-major axis</strong>, or the radius at the
equator (measured in meters) and the <strong>inverse flattening</strong>
ratio, defined as the ratio between the semi-major axis, and the difference
between the semi-major and semi-minor axes. Note that the earth is not a
true ellipsoid, both because the gravitational and centrifugal bulging is
not solved exactly by an ellipsoid, and because of local changes in gravity
due to, for example, large mountain ranges. However, an ellipsoid is
commonly used for cartographic applications. The ellipsoid matters because
it defines how latitude is measured and what path will be followed by a
"straight" line across the earth's surface.</p>

<p><strong>Datum</strong>: This is a reference location against which
measurements are made. There are generally two types of datums: horizontal
datums, which define horizontal (e.g. latitude-longitude) coordinate
systems, and vertical datums, which define the "zero altitude" point
against which altitude measurements are made.</p>

<p>The most common datum in use, and generally the one you will encounter most
often when writing location applications, is <strong>WGS84</strong>. This
datum comprises both horizontal and vertical parts. The WGS84 horizontal
datum defines the latitudes and longitudes used by the global positioning
system (GPS). Latitudes are defined using the WGS84 reference ellipsoid,
using the standard geodetic definition of the angle from the normal to the
ellispoid. Longitudes are measured relative to the *prime meridian*.
(Interestingly, the WGS84 prime meridian is not exactly on the historical
Greenwich prime meridian that passes through the Royal Observatory. A shift
of about 100 meters to the east was made in order to make WGS84 more
closely match a commonly-used North America-specific datum.)</p>

<p>The WGS84 vertical datum is a bumpy ellipsoid representing nominal sea
level for all parts of the earth. This shape is also known as the
<strong>geoid</strong>.</p>

<p>A geographic coordinate system is generally defined by a datum and a prime
meridian. A projected coordinate system starts from a geographic coordinate
system and includes additional parameters specific to the projection.</p>

<p>Which coordinate system should you use for location data? The usual simple
answer is WGS84. Because this is the same worldwide geographic coordinate
system that GPS uses, as do most geocoding services and so forth, most of
the data you will encounter will be in WGS84. Only in certain
locale-specific cases might a different coordinate system be in common use.
However, remember that WGS84 is a geographic coordinate system, not a
projected coordinate system. It does not make sense to say that your map
uses WGS84, because chances are your map is a flat map, not a map wrapped
around the WSG84 ellipsoidal shape.</p>

<p>What about Google and Bing maps? They use a combination of two coordinate
systems with a projection. The API inputs take latitude and longitude in
the WGS84 coordinate system. However, the maps themselves are Mercator
projections (with a minor modification to make computations easier), and so
the map implementations transform the coordinates internally. Again, Morten
Nielsen provides a more <a
href="http://www.sharpgis.net/post/2007/07/27/The-Microsoft-Live-Maps-and-Google-Maps-projection.aspx">detailed
description</a>.</p>

<h3 id="label-4.4.+Using+Proj4">4.4. Using Proj4</h3>

<p>Under most circumstances, when you’re working with geographic data in RGeo,
you can probably use either the spherical factory (if you just want to deal
with points on the sphere) or the simple mercator factory (if you want to
deal with objects as they would appear on Google or Bing maps). However, if
you need to work with arbitrary projections, you can use <a
href="http://trac.osgeo.org/proj/">Proj</a>, a C library that understands
coordinate systems and handles the math involved. Proj defines a syntax for
specifying coordinate systems based on the above parameters, and provides
an implementation for transforming coordinates from one coordinate system
to another. Its syntax has become a <em>de facto</em> standard.</p>

<p>RGeo provides a Ruby wrapper around the Proj interface, and integrates proj
into its representation of geometric objects. You can use the Proj syntax
to specify the coordinate system for input data, and tell RGeo to translate
it to a different coordinate system for analysis or output. RGeo’s
geographic factories can also be configured with a particular projection
using the Proj syntax, and automatically convert between latitude-longitude
and that projection’s coordinate system. For example:</p>

<pre class="ruby"><span class="ruby-comment"># Geographic factory that projects to a world mercator projection.</span>
<span class="ruby-comment"># Note the ellps and datum set to WGS84.</span>
<span class="ruby-identifier">factory</span> = <span class="ruby-constant">RGeo</span><span class="ruby-operator">::</span><span class="ruby-constant">Geographic</span>.<span class="ruby-identifier">projected_factory</span>(:<span class="ruby-identifier">projection_proj4</span> =<span class="ruby-operator">&gt;</span>
  <span class="ruby-string">'+proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs'</span>)

<span class="ruby-comment"># Create a point with the long/lat of Seattle</span>
<span class="ruby-identifier">point</span> = <span class="ruby-identifier">factory</span>.<span class="ruby-identifier">point</span>(<span class="ruby-value">-122.3</span>, <span class="ruby-value">47.6</span>)

<span class="ruby-comment"># Project the point to mercator projection coordinates.</span>
<span class="ruby-comment"># The coordinates are in &quot;meters&quot; at the equator.</span>
<span class="ruby-identifier">point</span>.<span class="ruby-identifier">projection</span>.<span class="ruby-identifier">as_text</span>   <span class="ruby-comment"># =&gt; &quot;POINT (-13614373.724017357 6008996.432357133)&quot;</span>
</pre>

<h3 id="label-4.5.+Spatial+Reference+Systems+and+the+EPSG+Dataset">4.5. Spatial Reference Systems and the EPSG Dataset</h3>

<p>The OGC also defines a syntax for specifying coordinate systems, the <a
href="http://www.opengeospatial.org/standards/ct">Coordinate Transformation
Services Specification</a>. This specification defines both an object model
and a well-known text representation for coordinate systems and
transformations. RGeo also provides basic support for this specification;
you can attach an OGC coordinate system specification to a factory to
indicate the coordinate system. However, if you want RGeo to convert
spatial data between coordinate systems, you must use Proj4 syntax.</p>

<p>Finally, there also exists a <em>de facto</em> standard database of
coordinate systems and related parameters, published by EPSG (now the OGP
Geomatics Committee). This is a set of coordinate systems, each tagged with
a well-known ID number, including geographic and projected systems. You can
browse this database, including both OGC and Proj4 representations, at <a
href="http://www.spatialreference.org/.">www.spatialreference.org/.</a>
This database is also included as a table in many popular spatial databases
including PostGIS and SpatiaLite. Typically, the EPSG number is used as the
SRID identifying the coordinate system for geometric objects stored in the
database.</p>

<p>The most common EPSG number in use is 4326, which identifies the WGS84
geographic (longitude-latitude) coordinate system on the WGS84 ellipsoid.
In fact, current versions of PostGIS restrict geography objects to this
SRID. Be aware, again, that this is a non-projected ellipsoidal coordinate
system. If you load EPSG 4326 data directly into, say, a Cartesian
implementation in RGeo, then the basic data fields will work fine, but size
and distance functions, as well as spatial analysis operations such as
intersections, may yield surprising or incorrect results because the data’s
coordinate system does not match how RGeo is treating it.</p>

<p>The EPSG database is so ubiquitous that it is commonly distributed along
with spatial database systems such as PostGIS and SpatiaLite, as described
in the next section. RGeo takes advantage of this by providing automatic
lookup of the coordinate system from the EPSG number. If you use one of
these spatial databases, you do not need to know the exact definition of
the coordinate system; just provide the EPSG number in the SRID field, and
the RGeo factory will know how to construct the correct Proj4 syntax for
performing coordinate conversions. You can even create custom spatial
reference system databases if you do not want to use the provided standard
databases.</p>

<h2 id="label-5.+Spatial+Databases">5. Spatial Databases</h2>

<p>Now that we have a basic understanding of geospatial data, we’ll turn to
the question of storing and querying for this data.</p>

<p>As we have seen, there exist a variety of ways to serialize geometric
objects, notably the OGC “well-known text” and “well-known binary” formats.
The simplest way to store such objects in a database, then, is to simply
serialize the object into a blob. However, this would not allow us to
perform queries with conditions relating to the object itself. Typical
location-based applications may need to run queries such as “give me all
the locations within one mile of a particular position.” This kind of
capability is the domain of spatial databases.</p>

<h3 id="label-5.1.+Spatial+Queries+and+Spatial+Indexes">5.1. Spatial Queries and Spatial Indexes</h3>

<p>The OGC defines a <a
href="http://www.opengeospatial.org/standards/sfs">specification</a>,
related to the SFS, describing SQL extensions for a spatial database. This
specification includes a table for spatial reference systems (that is,
coordinate systems) which can contain OGC and Proj4 representations, and a
table of metadata for geometry columns which stores such information as
type, dimension, and srid constraints. It also defines a suite of SQL
functions that you can call in a query. For example, in a compliant
database, to find all rows in “mytable” where the geometry-valued column
“geom” contains data within 5 units of the coordinates (10, 20), you might
be able to run a query similar to:</p>

<pre>SELECT * FROM mytable WHERE ST_Distance(geom, ST_WKTToSQL(&quot;POINT (10 20)&quot;)) &gt; 5;</pre>

<p>Like all database queries, however, when there are a large number of rows,
such a query can be slow if it has to do a full table scan. This is
especially true if it has to evaluate geometric functions like the above,
which can be numerically complex and slow to execute. To speed up queries,
it is necessary to index your spatial columns.</p>

<p>Spatial indexes are somewhat more complex than typical database indexes. A
typical B-tree index relies on a global ordering of data: the fact that you
can sort scalar values in a binary tree and hence perform logarithmic-time
searches. However, there isn’t an obvious global ordering for spatial data.
Should <code>POINT (0 1)</code> come before or after <code>POINT (1
0)</code>? And how do each of those compare with <code>LINESTRING (0 1, 1
0)</code>? Becase spatial data exists in two dimensions rather than one,
and can span finite ranges in additional to infinitesimal points, the
notion of a global ordering becomes ill-defined, and normal database
indexes do not apply as well as we would like.</p>

<p>Spatial databases handle the problem of indexing spatial data in various
ways, but most techniques are variants on an indexing algorithm known as an
R-tree. I won’t go into the details of how an R-tree works here. For the
interested, I recommend the text <a
href="http://www.amazon.com/dp/1558605886">“Spatial Databases With
Application To GIS”</a>, which covers a wide variety of issues related to
basic spatial database implementation. For our purposes, just note that for
large datasets, it is necessary to index the geometry columns, and that the
index creation process may be different from that of normal scalar columns.
The next sections provide some information specific to some of the common
spatial databases.</p>

<h3 id="label-5.2.+MySQL+Spatial">5.2. MySQL Spatial</h3>

<p><a href="http://mysql.com/">MySQL</a> maintains its dual reputation as
probably the easiest of the open source relational databases to manage, but
as tending to miss some features and standards compliance. Recent versions
of MySQL have spatial column support baked in, and they are extremely easy
to use: just create a column of type GEOMETRY, or POINT, or LINESTRING, or
any of the OGC types. You can also create spatial indexes simply by adding
the SPATIAL modifier to CREATE INDEX. Note, however, that as of MySQL 5.1,
only MyISAM tables support spatial indexes. If you're using Innodb, you can
add spatial columns but you can't index them.</p>

<pre>CREATE TABLE mytable(id INT NOT NULL PRIMARY KEY, latlon POINT) ENGINE=MyISAM;
CREATE SPATIAL INDEX idx_latlon ON mytable(latlon);</pre>

<p>MySQL represents data internally using a variant of WKB which has been
slightly modified by prepending 4 extra bytes to store an object’s SRID.
You can interpret this data directly, or use provided functions to convert
to and from WKB and WKT.</p>

<p>What MySQL lacks is support for most of the advanced spatial geometry
functions such as the relational operators (e.g. ST_Intersects(),
ST_Contains(), etc.), so you will not be able to perform complex geometric
calculations using the database engine. You’ll have to just load the data
into your application and use RGeo to perform those calculations. It also
does not provide the OGC-specified geometry columns or spatial reference
system tables. Because the former table is not present, you will not be
able to specify constraints on your geometries beyond the type: you will
not be able to constrain the SRID for a column, and columns will not be
able to support Z and M coordinates. Because the latter table is not
present, MySQL cannot perform coordinate system transformations itself, nor
provide you with the standard EPSG dataset for your own use.</p>

<p>In general, if you’re using MySQL for the rest of your application, and you
just need simple geospatial data capabilities, it’s very easy to use MySQL
spatial. Just make sure your table uses the MyISAM engine if you need to
index the geometry.</p>

<h3 id="label-5.3.+SpatiaLite">5.3. SpatiaLite</h3>

<p><a href="http://www.gaia-gis.it/spatialite/">SpatiaLite</a> is an add-on
library for the popular database <a
href="http://www.sqlite.org/">Sqlite</a>. It is close to a fully compliant
implementation of the OGC SQL specification, but as a result it is more
difficult to manage than MySQL.</p>

<p>To install SpatiaLite, you must compile it as a shared library, then load
that library as an extension using the appropriate sqlite API. This gives
you access to the full suite of spatial SQL functions defined by the OGC,
along with a set of utility functions for managing spatial columns and
indexes as well as the geometry columns and spatial reference systems
tables. These utility functions automatically create and manage the
appropriate entries in the geometry columns table and the triggers that
enforce type and SRID constraints and maintain the spatial indexes.</p>

<pre>CREATE TABLE mytable(id INTEGER PRIMARY KEY);
SELECT AddGeometryColumn('mytable', 'latlon', 4326, 'POINT', 'XY');
SELECT CreateSpatialIndex('mytable', 'latlon');</pre>

<p>Spatial indexes themselves are implemented using SpatiaLite’s Rtree
extension, and so queries that use a spatial index are a little more
complex to write. You have to join to the Rtree table, or use a nested
query:</p>

<pre>SELECT * FROM mytable WHERE id IN
  (SELECT pkid FROM idx_mytable_latlon WHERE
     xmin &gt; -123 AND xmax &lt; -122 AND ymin &gt; 47 AND ymax &lt; 48);</pre>

<p>SpatiaLite’s internal format is a binary format loosely based on the WKB,
but extended to include the SRID, as well as some internal bounding
rectangle data to speed up calculations. Like MySQL, SpatiaLite provides
functions to convert this data to and from WKB and WKT. I’m not completely
clear on this, but it does not seem that SpatiaLite supports Z and M
coordinates at this time.</p>

<h3 id="label-5.4.+PostGIS">5.4. PostGIS</h3>

<p>As <a href="http://www.postgresql.org/">PostgreSQL</a> is the most complete
(and complex) open-source relational database, so the <a
href="http://www.postgis.org/">PostGIS</a> add-on library is also the most
complete and complex of the spatial databases I discuss here. It is a
highly compliant implementation of the OGC SQL specification, including all
the needed functions and tables. It also supports spatial indexes using
PostgreSQL’s GiST (generalized search tree) index implementation.</p>

<p>Like SpatiaLite, PostGIS is compiled and installed as a plug-in library to
the database. Also like SpatiaLite, PostGIS provides a suite of utility
functions for managing spatial columns and updating the geometry columns
table. PostGIS indexes, however, are built in, and so use the more
traditional index creation syntax. Like SpatiaLite, PostGIS provides a
spatial reference systems table from which you can look up EPSG codes and
obtain Proj4 and OGC representations of coordinate systems.</p>

<pre>CREATE TABLE mytable(id INTEGER PRIMARY KEY);
SELECT AddGeometryColumn('mytable', 'latlon', 4326, 'POINTM', 3);
CREATE INDEX idx_mytable_latlon ON mytable USING GIST (latlon);</pre>

<p>PostGIS actually provides two types of spatial columns: geometry and
geography. The former assumes a flat coordinate system and performs
Euclidean/Cartesian geometric calculations using any EPSG coordinate system
you choose. The latter is specifically designed for geographic
(longitude-latitude) coordinate systems. It performs calculations on the
sphereoid and only works with EPSG 4326; however, some of the more advanced
functions are not implemented because the calculations involved would be
prohibitively complex. When you create a spatial column in PostGIS, you
will need to decide whether to use the geometry or geography type.</p>

<p>PostGIS uses as its internal format a variant of WKB known as EWKB. This
variant provides support for Z and M coordinates as well as embedded SRID
values. PostGIS also defines an corresponding EWKT format adding Z and M
support and SRIDs to WKT, and provides conversion functions. The EWKB and
EWKT variants are commonly used and so are supported by RGeo’s WKB and WKT
parsers.</p>

<h3 id="label-5.5.+RGeo+ActiveRecord+Integration">5.5. RGeo ActiveRecord Integration</h3>

<p>RGeo provides extra support for web applications built on Ruby On Rails or
similar frameworks that use the ActiveRecord library, in the form of a
suite of ActiveRecord connection adapters for the various spatial databases
we have covered. These connection adapters subclass the stock database
connection adapters, and add support for the RGeo geometric data types. You
can create spatial columns and indexes using extensions to the ActiveRecord
schema definition functions, and the appropriate fields on your
ActiveRecord objects will appear as RGeo spatial data objects. Some of
these adapters also modify ActiveRecord’s rake tasks to help automate the
process of creating and maintaining spatial databases. Using one of these
connection adapters is probably the easiest way to integrate your Rails
application with a spatial database.</p>

<p>RGeo’s spatial ActiveRecord adapters are provided in separate gems, named
according to the recommended convention. These are the names of these
connection adapters:</p>
<ul><li>
<p><strong>mysqlspatial</strong>: Subclasses the mysql adapter and adds
support for MySQL's spatial types. Available as the
<strong>activerecord-mysqlspatial-adapter</strong> gem.</p>
</li><li>
<p><strong>mysql2spatial</strong>: Subclasses the mysql2 adapter and adds
support for MySQL's spatial types. Available as the
<strong>activerecord-mysql2spatial-adapter</strong> gem.</p>
</li><li>
<p><strong>spatialite</strong>: Subclasses the sqlite3 adapter and adds
support for the SpatiaLite extension. Available as the
<strong>activerecord-spatialite-adapter</strong> gem.</p>
</li><li>
<p><strong>postgis</strong>: Subclasses the postgresql adapter and adds
support for the PostGIS extension. Available as the
<strong>activerecord-postgis-adapter</strong> gem.</p>
</li></ul>

<h3 id="label-5.6.+Commercial+SQL+Databases+and+Non-SQL+Databases">5.6. Commercial SQL Databases and Non-SQL Databases</h3>

<p>Major commercial relational databases also include various levels of
support for the OGC SQL specification. Recent versions of the venerable
Oracle database include <a
href="http://www.oracle.com/technetwork/database/options/spatial/index.html">Oracle
Spatial</a>, and Microsoft’s latest SQL Server also includes <a
href="http://www.microsoft.com/sqlserver/2008/en/us/spatial-data.aspx">spatial
data tools</a>. I have not had a chance to evaluate the spatial tools in
these commercial databases, though I have heard them described as
“powerful, but moody”. RGeo does not yet have direct ActiveRecord support
for Oracle or SQL Server spatial.</p>

<p>Several “NoSQL” databases also provide various degrees of limited support
for geospatial data. Because these databases intentionally eschew the SQL
standard, there is no OGC-defined standard interface for these databases,
and so you will need to study the individual database’s documentation to
get an idea of the capabilities and API. RGeo does not yet provide direct
integration support for non-relational databases, but in most cases, it
should not be too difficult to write glue code yourself.</p>

<p><a href="http://www.mongodb.org/">MongoDB</a> provides limited support for
storing and indexing point data. In the current stable release series
(1.8.x), you can store a point field as a longitude-latitude pair, and
perform basic proximity and bounds searches. It does not support LineString
or Polygon data. As far as I can determine, MongoDB uses a simple indexing
system based on geo-hashing, which also limits its ability to support
non-point data.</p>

<p><a href="http://github.com/couchbase/geocouch">GeoCouch</a> is an addition
to <a href="http://couchdb.apache.org/">CouchDB</a> that provides an
r-tree-based spatial index for point data. I have not studied it much, but
it also appears to be limited to point data.</p>

<h2 id="label-6.+Location+Service+Integration">6. Location Service Integration</h2>

<p>When writing a location-aware application, you will often need to interact
with external sources of data and external location-based services. RGeo
provides several tools to facilitate this data transfer.</p>

<h3 id="label-6.1.+Shapefiles+and+Spatial+Data+Sets">6.1. Shapefiles and Spatial Data Sets</h3>

<p><a href="http://www.esri.com/">ESRI</a> is one of the oldest and most
well-known GIS corporations, developing a suite of applications including
the venerable <a
href="http://www.esri.com/software/arcgis/index.html">ArcGIS</a>. ESRI also
created the Shapefile, a geospatial data file format that has become a
<em>de facto</em> standard despite its legacy and somewhat awkward
characteristics. Today, many of the widely-available geospatial data sets
are distributed as shapefiles.</p>

<p>The shapefile format is specified in an ESRI <a
href="http://www.esri.com/library/whitepapers/pdfs/shapefile.pdf">whitepaper</a>.
It typically comprises three files: the main file “*.shp” containing the
actual geometric data, a corresponding index file “*.shx” providing offsets
into the .shp file to support random access, and a corresponding file
“*.dbf” in dBASE format that stores arbitrary attributes for the shape
records. Many GIS systems can read and/or write shapefiles. SpatiaLite can
treat a shapefile as an external “virtual table”. An optional RGeo module,
RGeo::Shapefile (distributed as the gem <strong>rgeo-shapefile</strong>)
can read shapefiles and expose their contents as RGeo’s geometric data
types.</p>

<h3 id="label-6.2.+GeoJSON+and+Location-Based+Services">6.2. GeoJSON and Location-Based Services</h3>

<p>Location is becoming a common feature of web services as well. An emerging
standard in the encoding of geographic data in a web service is <a
href="http://www.geojson.org/">GeoJSON</a>, an geospatial data format based
on JSON. GeoJSON can encode any of the OGR geometry types, along with
attributes, bounding boxes, and coordinate system specifications. <a
href="http://www.simplegeo.com/">SimpleGeo</a> is one of several
high-profile location based APIs now using GeoJSON. RGeo also provides an
optional module RGeo::GeoJSON (distributed as the gem
<strong>rgeo-geojson</strong>) that can read and write this format.</p>

<p>Other common formats that may be used by web services include <a
href="http://www.georss.org/">GeoRSS</a>, an extension to RSS and Atom for
geotagging RSS feed entries, and <a
href="http://www.opengeospatial.org/standards/kml">KML</a>, an XML-based
markup language for geographic information originally developed by Google
and recently adopted as an OGC standard. The GeoRuby library provides
rudimentary support for these formats. RGeo does not yet, but appropriate
optional modules are on the to-do list.</p>

<h2 id="label-7.+Conclusion">7. Conclusion</h2>

<p>Geospatial systems represent a rapidly growing and evolving area of
technology, and helpful resources are often difficult to find outside of
the relatively niche GIS community. Writing a robust location-aware
application sometimes requires an understanding of a number of GIS
concepts, tools, and specifications. We have covered a few of the most
important ones in this document.</p>

<p>At the time of this writing, a number of open source geospatial tools and
libraries are starting to mature. For Ruby and Rails developers, the RGeo
library is one of these emerging tools, and represents an important step
towards supporting the next generation of geospatial applications.</p>

<h2 id="label-History"><a href="History_rdoc.html">History</a></h2>
<ul><li>
<p>Version 0.1 / 5 Dec 2010: Initial draft</p>
</li><li>
<p>Version 0.2 / 7 Dec 2010: More code examples and other minor updates</p>
</li><li>
<p>Version 0.3 / 17 Feb 2011: Further minor clarifications and fixes, and
coverage of features in newer RGeo releases</p>
</li><li>
<p>Version 0.4 / 23 May 2011: Minor updates to keep up with new releases</p>
</li></ul>

</div>



<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 3.12.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

